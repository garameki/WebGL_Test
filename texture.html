<!DOCTYPE html><html lang="jp"><head><meta charset="utf-8"><title>WebGL Demo</title>
<link rel="sylesheet" href="">
<!--Fragment shader program-->
<script id="shader-fs" type="x-shader/x-fragment">
	varying lowp vec4 vColor;
	varying highp vec2 vTextureCoord;

	uniform sampler2D uSampler;

	void main(void) {
//		gl_FragColor = texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t));
		gl_FragColor = texture2D(uSampler,vTextureCoord);
//		gl_FragColor = vColor;
	}
</script>
<!--Vertex shader program-->
<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec4 aVertexColor;
	attribute vec2 aTextureCoord;

	uniform mat4 uModelViewMatrix;
	uniform mat4 uProjectionMatrix;

	uniform float uPointSizeFloat;

	varying lowp vec4 vColor;
	varying lowp vec2 vTextureCoord;

	void main(void) {
		gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition,1.0);
		vColor = aVertexColor;
		vTextureCoord = aTextureCoord;
		gl_PointSize = uPointSizeFloat;
	}
</script>

<script type='text/javascript'>

function initTextures(gl){
	cubeTexture = gl.createTexture();
	cubeImage = new Image();
	cubeImage.onload = function (){
		var canvas = document.createElement('canvas');
		document.getElementsByTagName('body')[0].appendChild(canvas);
		canvas.width = 100;
		canvas.height = 50;
		canvas.style.position='absolute';
		canvas.style.left='0px';
		canvas.style.top='0px';
		canvas.style.backgroundColor='transparent';
		canvas.style.globalAlpa=0.7;
		canvas.style.zIndex=100;
		var ctx = canvas.getContext('2d');
		ctx.drawImage(cubeImage,0,0);
		handleTextureLoaded(gl,cubeImage,cubeTexture);
	}
	var h = new XMLHttpRequest();
	h.responseType = "blob";
	h.onload = function(){
//console.log("response=",h.response);
		var reader = new FileReader();
		reader.onloadend = function(){
//console.log("result=",reader.result);
			cubeImage.src = reader.result;
		}
		reader.readAsDataURL(h.response);
	}
	h.open('GET',"http://localhost:8000/documents/games/3d/niku_stand2.png");
	h.send();
//and Uhm...
// chrome.exe --disable-web-security --user-data-dir//


}
function handleTextureLoaded(gl,image,texture){//gl.TEXTURE_2Dオブジェクトのプロパティーに値を入れる操作を行う
	gl.bindTexture   (gl.TEXTURE_2D,texture);
	gl.texImage2D    (gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,image);
	gl.texParameteri (gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
	gl.texParameteri (gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR_MIPMAP_NEAREST);//gl.TEXTURE_2Dにbit演算している？
	gl.generateMipmap(gl.TEXTURE_2D);//gl.TEXTURE_2Dをmipmapに適用
//bad	gl.bindTexture   (gl.TEXTURE_2D,null);
}

	






function start(){
	var canvas = document.getElementById('glcanvas');
	canvas.width=canvas.clientWidth;//necessary
	canvas.height=canvas.clientHeight;//necessary
	var gl=canvas.getContext("webgl");
	if(!gl){
		alert('Unable to initialize WebGL.Your browser or machine may not support it.');
		return;
	}



	gl.viewport(0,0,gl.canvas.width,gl.canvas.height);//クリップ空間の-1～1の値をcanvasの大きさに変換する
	gl.clearColor(0.0, 0.0, 0.0, 1.0);	//Clear to black,fully opaque
	gl.clearDepth(1.0);			//Clear everything
	gl.enable(gl.DEPTH_TEST);		//Enable depth testing	    		// 深度テストを有効化
	gl.depthFunc(gl.LEQUAL);		//Near things obscure far things	// 近くにある物体は、遠くにある物体を覆い隠す
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);

	//for rectangle test
{
//	gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);
//    gl.enable(gl.SCISSOR_TEST);
//   gl.scissor(30, 10, 60, 60);//60x60の正方形
//    gl.clearColor(1.0, 1.0, 0.0, 1.0);
//    gl.clear(gl.COLOR_BUFFER_BIT);
}



	initTextures(gl);



	var oShader = initShaders(gl);
	var aModels = [];
	var oModel;

	oModel = { };
	oModel.base = regularHexahedron();
	oModel.buffers = setModelToBuffer(gl,oModel);
	oModel.mvMat = new mvMat_random();//function to rotation, translation and expand
	aModels.push(oModel);
console.log(oModel);
//	oModel = { };
//	oModel.base = regularTetrahedron();
//	oModel.buffers = setModelToBuffer(gl,oModel);
//	oModel.mvMat = new mvMat_random();
//	aModels.push(oModel);
//console.log(oModel);

	var timeBefore=0;
	var angle=0;
	function render(timeStamp){
		if(timeStamp - timeBefore>10){
			angle+=1;
			angle=Math.floor(angle*10)/10;
			if(angle>360)angle=0;
			PRINT_INFO.innerText=angle.toString();
			drawScene(gl,oShader,aModels,angle);
			timeBefore = timeStamp;
		}
		window.requestAnimationFrame(render);
	}
	window.requestAnimationFrame(render);
}

function initShaders(gl) {
	var fragmentShader = getShader(gl,"shader-fs");//プログラムをロードしてコンパイルして返す
	var vertexShader = getShader(gl,"shader-vs");//プログラムをロードしてコンパイルして返す




		//シェーダープログラムを作成
	var shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram,vertexShader);
	gl.attachShader(shaderProgram,fragmentShader);
	gl.linkProgram(shaderProgram);

	//シェーダープログラムを作成できない場合はアラートを表示
	if(!gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){
		alert("can't initialize the shader program");
		return null;
	}

	gl.useProgram(shaderProgram);//githubではdrawScene()内で実行

		//シェーダープログラムで使う配列変数を使用可能にする
	//プログラムのどこにあるのかを取得
	//使ってもいいよリストに登録
	var positionsLocation = gl.getAttribLocation(shaderProgram,"aVertexPosition");//""内は特殊言語の実装参照してる
	gl.enableVertexAttribArray(positionsLocation);//githubではdrawScene()内で実行

	var colorsLocation = gl.getAttribLocation(shaderProgram,"aVertexColor");
	gl.enableVertexAttribArray(colorsLocation);

	var textcoordLocation = gl.getAttribLocation(shaderProgram,"aTextureCoord");
	gl.enableVertexAttribArray(textcoordLocation);

	return {
		positionLoc:positionsLocation,
		colorLoc:colorsLocation,
		textcoordLoc:textcoordLocation,
		prog:shaderProgram
	}
}

function getShader(gl,id){
	var shaderScript,theSource,currentChild,shader;

	shaderScript = document.getElementById(id);

	if(!shaderScript) {
		return null;
	}

	theSource = "";
	currentChild = shaderScript.firstChild;

	while(currentChild) {
		if(currentChild.nodeType == currentChild.TEXT_NODE){
			theSource += currentChild.textContent;
		}

		currentChild = currentChild.nextSibling;
	}

	if (shaderScript.type == "x-shader/x-fragment"){
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	} else if (shaderScript.type == "x-shader/x-vertex"){
		shader = gl.createShader(gl.VERTEX_SHADER);
	} else {
		// 未知のシェーダータイプ
		PRINT_CAUTION.innerHTML+="Unknown shader type.The element type of shader program must be 'x-shader/x-vertex' or 'x-shader/x-fragment' now."+"<br>";
		return null;
	}

	gl.shaderSource(shader,theSource);

	//シェーダープログラムをコンパイル
	gl.compileShader(shader);

	//whether or not success to compileコンパイルが成功したかを確認
	if (!gl.getShaderParameter(shader,gl.COMPILE_STATUS)) {
		alert("Shader compile error occured : " + id + " : " + gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}

function regularTetrahedron(){
	//create tetrahedron
	var ra=1.0;
	var rb=2*Math.pow(2,0.5)/3*ra;
	var x1=0,y1=0,z1=ra;
	var x2=0,y2=rb,z2=-ra/4;
	var x3=rb*Math.sin(120*Math.PI/180),y3=rb*Math.cos(120*Math.PI/180),z3=-ra/4;
	var x4=rb*Math.sin(240*Math.PI/180),y4=rb*Math.cos(240*Math.PI/180),z4=-ra/4;

	//頂点の位置情報をバッファを作ってそこに入れる
	var positions = [
		x1,y1,z1,
		x2,y2,z2,
		x3,y3,z3,

		x1,y1,z1,
		x2,y2,z2,
		x4,y4,z4,

		x1,y1,z1,
		x3,y3,z3,
		x4,y4,z4,

		x2,y2,z2,
		x3,y3,z3,
		x4,y4,z4
	];

	//頂点の色情報をバッファを作ってそこに入れる
	var colors = [
		1.0, 1.0, 1.0, 1.0,
		0.0,0.0,0.9,1.0,
		0.9,0.1,0.1,1.0,
		1.0, 1.0, 1.0, 1.0,
		0.0,0.0,0.9,1.0,
		0.1,1.0,0.2,1.0,
		1.0, 1.0, 1.0, 1.0,
		0.9,0.1,0.1,1.0,
		0.1,1.0,0.2,1.0,
		0.0,0.0,0.9,1.0,
		0.9,0.1,0.1,1.0,
		0.1,1.0,0.2,1.0,
	];

	var textureCoordinates = [
		0.0,0.0,
		1.0,0.0,
		1.0,1.0,

		0.0,0,0,
		0.0,1.0,
		1.0,1.0,

		0.0,0.0,
		1.0,0.0,
		1.0,1.0,

		0.0,0,0,
		0.0,1.0,
		1.0,1.0
	];

	var indices = [
0,1,2,
3,4,5,
6,7,8,
9,10,11
];	

	return {
		n:positions.length/3,
		pos:positions,
		col:colors,
		tex:textureCoordinates,
		ind:indices
	}
}

function regularHexahedron(){
		//regular hexahedron
	var newPositions = [

1.0,1.0,1.0,
1.0,-1.0,1.0,
-1.0,-1.0,1.0,
-1.0,1.0,1.0,

1.0,1.0,-1.0,
1.0,-1.0,-1.0,
-1.0,-1.0,-1.0,
-1.0,1.0,-1.0,

1.0,1.0,1.0,
1.0,1.0,-1.0,
-1.0,1.0,-1.0,
-1.0,1.0,1.0,

1.0,-1.0,1.0,
1.0,-1.0,-1.0,
-1.0,-1.0,-1.0,
-1.0,-1.0,1.0,

1.0,1.0,1.0,
1.0,1.0,-1.0,
1.0,-1.0,-1.0,
1.0,-1.0,1.0,

-1.0,1.0,1.0,
-1.0,1.0,-1.0,
-1.0,-1.0,-1.0,
-1.0,-1.0,1.0

];


	var positions = [
		1.0,1.0,1.0,
		-1.0,1.0,1.0,
		-1.0,-1.0,1.0,
			1.0,1.0,1.0,
			-1.0,-1.0,1.0,
			1.0,-1.0,1.0,	

		1.0,1.0,1.0,
		-1.0,1.0,1.0,
		-1.0,1.0,-1.0,
			1.0,1.0,1.0,
			-1.0,1.0,-1.0,
			1.0,1.0,-1.0,

		1.0,1.0,1.0,
		1.0,-1.0,1.0,
		1.0,-1.0,-1.0,
			1.0,1.0,1.0,
			1.0,-1.0,-1.0,
			1.0,1.0,-1.0,

		1.0,1.0,-1.0,
		-1.0,1.0,-1.0,
		-1.0,-1.0,-1.0,
			1.0,1.0,-1.0,
			-1.0,-1.0,-1.0,
			1.0,-1.0,-1.0,	

		1.0,-1.0,1.0,
		-1.0,-1.0,1.0,
		-1.0,-1.0,-1.0,
			1.0,-1.0,1.0,
			-1.0,-1.0,-1.0,
			1.0,-1.0,-1.0,

		-1.0,1.0,1.0,
		-1.0,-1.0,1.0,
		-1.0,-1.0,-1.0,
			-1.0,1.0,1.0,
			-1.0,-1.0,-1.0,
			-1.0,1.0,-1.0
	];

	var newColors = [

		0.3,1.0,1.0,0.1,
		0.3,1.0,1.0,0.1,
		0.3,1.0,1.0,0.1,
		0.3,1.0,1.0,0.1,

		1.0,0.2,0.5,0.5,
		1.0,0.2,0.5,0.5,
		1.0,0.2,0.5,0.5,
		1.0,0.2,0.5,0.5,

		0.7,0.3,0.8,0.9,
		0.7,0.3,0.8,0.9,
		0.7,0.3,0.8,0.9,
		0.7,0.3,0.8,0.9,

		0.6,1.0,0.6,0.9,
		0.6,1.0,0.6,0.9,
		0.6,1.0,0.6,0.9,
		0.6,1.0,0.6,0.9,

		0.4,0.2,0.1,0.9,
		0.4,0.2,0.1,0.9,
		0.4,0.2,0.1,0.9,
		0.4,0.2,0.1,0.9,

		1.0,1.0,0.1,0.9,
		1.0,1.0,0.1,0.9,
		1.0,1.0,0.1,0.9,
		1.0,1.0,0.1,0.9,

];
	var colors = [
		0.3,1.0,1.0,0.1,
		0.3,1.0,1.0,0.1,
		0.3,1.0,1.0,0.1,
			0.3,1.0,1.0,0.1,
			0.3,1.0,1.0,0.1,
			0.3,1.0,1.0,0.1,

		1.0,0.2,0.5,0.5,
		1.0,0.2,0.5,0.5,
		1.0,0.2,0.5,0.5,
			1.0,0.2,0.5,0.5,
			1.0,0.2,0.5,0.5,
			1.0,0.2,0.5,0.5,

		0.7,0.3,0.8,0.9,
		0.7,0.3,0.8,0.9,
		0.7,0.3,0.8,0.9,
			0.7,0.3,0.8,0.9,
			0.7,0.3,0.8,0.9,
			0.7,0.3,0.8,0.9,

		0.6,1.0,0.6,0.9,
		0.6,1.0,0.6,0.9,
		0.6,1.0,0.6,0.9,
			0.6,1.0,0.6,0.9,
			0.6,1.0,0.6,0.9,
			0.6,1.0,0.6,0.9,

		0.4,0.2,0.1,0.9,
		0.4,0.2,0.1,0.9,
		0.4,0.2,0.1,0.9,
			0.4,0.2,0.1,0.9,
			0.4,0.2,0.1,0.9,
			0.4,0.2,0.1,0.9,

		1.0,1.0,0.1,0.9,
		1.0,1.0,0.1,0.9,
		1.0,1.0,0.1,0.9,
			1.0,1.0,0.1,0.9,
			1.0,1.0,0.1,0.9,
			1.0,1.0,0.1,0.9
	];


	var textureCoordinates = [
		1.0,0.0,
		1.0,1.0,
		0.0,1.0,
		0.0,0.0,

		1.0,0.0,
		1.0,1.0,
		0.0,1.0,
		0.0,0.0,

		1.0,0.0,
		1.0,1.0,
		0.0,1.0,
		0.0,0.0,

		1.0,0.0,
		1.0,1.0,
		0.0,1.0,
		0.0,0.0,

		1.0,0.0,
		1.0,1.0,
		0.0,1.0,
		0.0,0.0,

		1.0,0.0,
		1.0,1.0,
		0.0,1.0,
		0.0,0.0
];


	var indices = [
0,1,2,0,2,3,
4,5,6,4,6,7,
8,9,10,8,10,11,
12,13,14,12,14,15,
16,17,18,16,18,19,
20,21,22,20,22,23
];


	return {
		n:positions.length/3,
		pos:newPositions,
		col:newColors,
		tex:textureCoordinates,
		ind:indices
	}
}

function setModelToBuffer(gl,oModel){
	//生成したバッファをWebGLBufferにバインドしたら、
	//あとはそれにvertexのattributionをbufferDataを使って
	//頂点の座標、頂点の色、テキストデータなどをバッファに放り込むだけ

	//position to buffer
	var positionsBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER,positionsBuffer);
	gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(oModel.base.pos),gl.STATIC_DRAW);

	//color to buffer
	var colorsBuffer = gl.createBuffer();//正方形のvertices
	gl.bindBuffer(gl.ARRAY_BUFFER,colorsBuffer);
	gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(oModel.base.col),gl.STATIC_DRAW);

	//texture position to buffer
	var textureCoordinateBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER,textureCoordinateBuffer);
	gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(oModel.base.tex),gl.STATIC_DRAW);

	//indices to ELEMENT buffer
	var indexBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer);
	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(oModel.base.ind),gl.STATIC_DRAW);

	return {
		pointPos:positionsBuffer,
		pointCol:colorsBuffer,
		pointTex:textureCoordinateBuffer,
		pointInd:indexBuffer
	}
}

function sendBufferData(gl,oShader,oBuffer){

	//バッファにある頂点の位置情報や色情報をどう使用するかを決めてGLSLに渡す

	//引数の準備
	var type = gl.FLOAT;
	var normalize = false;
	var stride = 0;//shaderを呼び出すごとに進むバイト数//これは(buffer.slice((offset + i) * stride,size);)という意味
	var offset = 0;

	gl.bindBuffer(gl.ARRAY_BUFFER,oBuffer.pointPos);
	numComponents = 3;//number of column
	gl.vertexAttribPointer(oShader.positionLoc,numComponents,type,normalize,stride,offset);

	gl.bindBuffer(gl.ARRAY_BUFFER,oBuffer.pointCol);
	numComponents = 4;//列の数
	gl.vertexAttribPointer(oShader.colorLoc,numComponents,type,normalize,stride,offset);

	gl.bindBuffer(gl.ARRAY_BUFFER,oBuffer.pointTex);
	numComponents = 2;//列の数
	gl.vertexAttribPointer(oShader.textcoordLoc,numComponents,type,normalize,stride,offset);

	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,oBuffer.pointInd);
//this part below is not necessary for the element as indices
//	numComponents = 3;//列の数
//	gl.vertexAttribPointer(oShader.indexLoc,numComponents,type,normalize,stride,offset);

}



function sendPerspectiveMatrix(gl,oShader){

	/*
		from cite site:
		Create a perspective matrix, a special matrix that is
		used to simulate the distortion of perspective in a camera.
		Our field of view is 45 degrees, with a (width/height)
		ratio that matches the display size of the canvas
		and we only want ot see objects between 0.1 units
		and 100 units away from the camera.
	*/
		//perspective matrix...MatP was already defined at global position
	var fieldOfView = 90 * Math.PI / 180;	//in radian;
	var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
	var zNear = 0.001;
	var zFar = 100.0;
	MatP.init(fieldOfView,aspect,zNear,zFar);
	var projectionMatrix=new Array(16);
	MatP.store(projectionMatrix);

	//uniform mat4 uProjectionMatrixへ値を転送
	var pUniform = gl.getUniformLocation(oShader.prog,"uProjectionMatrix");//""内は特殊言語の実装参照してる
	if(!pUniform){PRINT_CAUTION.innerHTML+="pUniform is "+pUniform+"<br>";return null;}
	gl.uniformMatrix4fv(pUniform,false,new Float32Array(projectionMatrix));

}


function mvMat_random(){

	var rx = Math.floor(Math.random()*100)/10;
	var ry = Math.floor(Math.random()*100)/10;
	var rz = Math.floor(Math.random()*100)/10;
	var m = Math.floor(Math.random()*3+1);
	var tx = 2-Math.floor(Math.random()*4);
	var ty = 2-Math.floor(Math.random()*4);

	return function(angle){
		//model view matrix...MatA was already defined in global scope
		MatA.init();
		MatA.trans(tx,ty,-6.0);
		MatA.rot(rx,ry,rz,m*angle*Math.PI/180);

		var matrix = new Array(16);
		MatA.store(matrix);

		return matrix;
	}
}

function sendModelViewMatrix(gl,oShader,mvMatrix){

		//Set the shader uniforms culclated above and something
	//uniform mat4 uModelViewMatrixへ値を転送
	var mvUniform = gl.getUniformLocation(oShader.prog,"uModelViewMatrix");
	if(!mvUniform){PRINT_CAUTION.innerHTML+="mvUniform is "+mvUniform+"<br>";return null;}
	gl.uniformMatrix4fv(mvUniform,false,new Float32Array(mvMatrix));

	//uniform float uPointSizeFloatへ値を転送
	var psUniform = gl.getUniformLocation(oShader.prog,"uPointSizeFloat");
	if(!psUniform){PRINT_CAUTION.innerHTML+="psUniform is "+psUniform+"<br>";return null;}
	gl.uniform1f(psUniform,10.0);
}


function drawScene(gl,oShader,aModels,angle){

	// カラーバッファや深度バッファをクリアする
	//Clear the canvas before we start drawing on it

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	var vertexOffset = 0;//このoffsetは頂点のx,y,zごとに進むので、データ的にはoffset*3(4?)ごとに進む

	for(var ii=0;ii<aModels.length;ii++){
		sendBufferData(gl,oShader,aModels[ii].buffers);
		sendPerspectiveMatrix(gl,oShader);
		sendModelViewMatrix(gl,oShader,aModels[ii].mvMat(angle));
//		gl.drawElements(gl.TRIANGLES,aModels[ii].base.n,gl.UNSIGNED_SHORT,vertexOffset);
		gl.drawElements(gl.TRIANGLES,aModels[ii].base.n,gl.UNSIGNED_SHORT,vertexOffset);
	}

//	gl.drawArrays(gl.TRIANGLE_STRIP,vertexOffset,vertexCount);
//	gl.drawArrays(gl.LINE_STRIP,vertexOffset,vertexCount);
//	PRINT_INFO.innerHTML+=gl.hasOwnProperty("PointSize").toString()+"<br>";
//	gl.drawArrays(gl.POINTS,vertexOffset,vertexCount);

}









//*****************************************************************************










</script>
<script id="matrix-library" type='text/javascript'>

/**
*define matrixes
*
*@variable {number} _x[1-4][1-4] result matrix
*@variable {number} _a[1-4][1-4] accumerate matrix e.g. answer of a calculation like multiplication
*@variable {number} _p[1-4][1-4] perspective matrix
*
*/
var _x11=void 0,_x12=void 0,_x13=void 0,_x14=void 0,_x21=void 0,_x22=void 0,_x23=void 0,_x24=void 0,_x31=void 0,_x32=void 0,_x33=void 0,_x34=void 0,_x41=void 0,_x42=void 0,_x43=void 0,_x44=void 0;//target matrix
var _a11=void 0,_a12=void 0,_a13=void 0,_a14=void 0,_a21=void 0,_a22=void 0,_a23=void 0,_a24=void 0,_a31=void 0,_a32=void 0,_a33=void 0,_a34=void 0,_a41=void 0,_a42=void 0,_a43=void 0,_a44=void 0;//answer matrix
var _p11=void 0,_p12=void 0,_p13=void 0,_p14=void 0,_p21=void 0,_p22=void 0,_p23=void 0,_p24=void 0,_p31=void 0,_p32=void 0,_p33=void 0,_p34=void 0,_p41=void 0,_p42=void 0,_p43=void 0,_p44=void 0;//answer matrix


/**
 *Make a matrix the unit matrix
 *
*/
var prepareAM = function makeAccumerateMatrixUnitMatrix(){
	_a11=1;_a12=0;_a13=0;_a14=0;
	_a21=0;_a22=1;_a23=0;_a24=0;
	_a31=0;_a32=0;_a33=1;_a34=0;
	_a41=0;_a42=0;_a43=0;_a44=1;
}

/**
 *Translate homo 4x4matrix of accumerate matrix
 *
 *@arg {number} x,y,z scalar of translation 
 *
*/
var translateAM = function translateAccumurateMatrix(x,y,z){
	_x11=_a11;_x12=_a12;_x13=_a13;_x14=_a14;
	_x21=_a21;_x22=_a22;_x23=_a23;_x24=_a24;
	_x31=_a31;_x32=_a32;_x33=_a33;_x34=_a34;
	_x41=_a11*x+_a21*y+_a31*z+_a41;
	_x42=_a12*x+_a22*y+_a32*z+_a42;
	_x43=_a13*x+_a23*y+_a33*z+_a43;
	_x44=_a14*x+_a24*y+_a34*z+_a44;

	_a11=_x11;_a12=_x12;_a13=_x13;_a14=_x14;
	_a21=_x21;_a22=_x22;_a23=_x23;_a24=_x24;
	_a31=_x31;_a32=_x32;_a33=_x33;_a34=_x34;
	_a41=_x41;_a42=_x42;_a43=_x43;_a44=_x44;
}
/**
 *Rotate homo 4x4matrix of accumurate matrix
 *
 *@arg {number} x,y,z axis vector
 *@arg {number} rad radian
 *
*/
var rotateAM = function rotateAccumurateMatrix(x,y,z,rad){
	var len = Math.sqrt(x*x+y*y+z*z);
	if(len < 0.001){
		PRINT_CAUTION.innerHTML+="axis Matrix is too short. x:"+x.toString()+" y:"+y.toString()+" z:"+z.toString()+"<br>";
		return null;//????
	}
	var x = x/len;
	var y = y/len;
	var z = z/len;

	//is this ok?????????
	var s = Math.sin(rad);
	var c = Math.cos(rad);
	var t = 1 - c;

	var g11 = x*x*t+c;	var g12 = y*x*t+z*s;	var g13 = z*x*t-y*s;
	var g21 = x*y*t-z*s;	var g22 = y*y*t+c;	var g23 = z*y*t+x*s;
	var g31 = x*z*t+y*s;	var g32 = y*z*t-x*s;	var g33 = z*z*t+c;

	_x11 = _a11 * g11 + _a21 * g12 + _a31 * g13;
	_x12 = _a12 * g11 + _a22 * g12 + _a32 * g13;
	_x13 = _a13 * g11 + _a23 * g12 + _a33 * g13;
	_x14 = _a14 * g11 + _a24 * g12 + _a34 * g13;

	_x21 = _a11 * g21 + _a21 * g22 + _a31 * g23;
	_x22 = _a12 * g21 + _a22 * g22 + _a32 * g23;
	_x23 = _a13 * g21 + _a23 * g22 + _a33 * g23;
	_x24 = _a14 * g21 + _a24 * g22 + _a34 * g23;

	_x31 = _a11 * g31 + _a21 * g32 + _a31 * g33;
	_x32 = _a12 * g31 + _a22 * g32 + _a32 * g33;
	_x33 = _a13 * g31 + _a23 * g32 + _a33 * g33;
	_x34 = _a14 * g31 + _a24 * g32 + _a34 * g33;
	
	_x41 = _a41;
	_x42 = _a42;
	_x43 = _a43;
	_x44 = _a44;

	_a11=_x11;_a12=_x12;_a13=_x13;_a14=_x14;
	_a21=_x21;_a22=_x22;_a23=_x23;_a24=_x24;
	_a31=_x31;_a32=_x32;_a33=_x33;_a34=_x34;
	_a41=_x41;_a42=_x42;_a43=_x43;_a44=_x44;
}

var storeAM = function storeAccumeMatrixToArray(arr){
	arr[0]=_a11;	arr[1]=_a12;	arr[2]=_a13;	arr[3]=_a14;
	arr[4]=_a21;	arr[5]=_a22;	arr[6]=_a23;	arr[7]=_a24;
	arr[8]=_a31;	arr[9]=_a32;	arr[10]=_a33;	arr[11]=_a34;
	arr[12]=_a41;	arr[13]=_a42;	arr[14]=_a43;	arr[15]=_a44;
}

/**
 *Make perspective matrix
 *
 *@arg {number} fov radian
 *@arg {number} aspect width/height of screen
 *@arg {number} near ?nearest distance to be able to take 
 *@arg {number} far ?farthest distance to be able to take
*/
var preparePM = function makePerspectiveMatrix(fov,aspectRatio,near,far){

	if(near == far){
		PRINT_CAUTION.innerHTML += "far equals to near in makePMatrix().<br>";
		return null;
	}
	var s = 1.0 / Math.tan(fov / 2);
	var nf = 1 / (near - far);

	_p11 = s/aspectRatio;	_p12 = 0;	_p13 = 0;			_p14 = 0;
	_p21 = 0;		_p22 = s;	_p23 = 0;			_p24 = 0;
	_p31 = 0;		_p32 = 0;	_p33 = (far + near) * nf;	_p34 = -1;
	_p41 = 0;		_p42 = 0;	_p43 = 2 * far * near * nf;	_p44 = 0;

//not important _p43,i think

//PRINT2.innerHTML = near.toString() + "&nbsp;&nbsp;&nbsp;" + far.toString() + "&nbsp&nbsp&nbsp" + (far*near*nf).toString();
//https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix
}
var storePM = function storePerspectiveMatrixToArray(arr){
	arr[0]=_p11;	arr[1]=_p12;	arr[2]=_p13;	arr[3]=_p14;
	arr[4]=_p21;	arr[5]=_p22;	arr[6]=_p23;	arr[7]=_p24;
	arr[8]=_p31;	arr[9]=_p32;	arr[10]=_p33;	arr[11]=_p34;
	arr[12]=_p41;	arr[13]=_p42;	arr[14]=_p43;	arr[15]=_p44;
}


var MatA = { };
Object.defineProperty(MatA,'init',{value:prepareAM,enumerable:true,configurable:true});
Object.defineProperty(MatA,'trans',{value:translateAM,enumerable:true,configurable:true});
Object.defineProperty(MatA,'rot',{value:rotateAM,enumerable:true,configurable:true});
Object.defineProperty(MatA,'store',{value:storeAM,enumerable:true,configurable:true});
var MatP = { };
Object.defineProperty(MatP,'init',{value:preparePM,enumerable:true,configurable:true});
Object.defineProperty(MatP,'store',{value:storePM,enumerable:true,configurable:true});


</script>
</head><body onload="start();"><div>
<h3 style="offset:0px;">Animating objects with WebGL</h3>
<h5 style="offset:0px;">using gl.TRIANGLES mode to draw and not using gl.ELEMENT_ARRAY_BUFFER mode to buffer</h5>
<p class="info" style="position:relative;top:0px;left:0px;color:black;font-size:30px:offset:0px">cite site:<a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL">MDN web docs moz://a(click next page)</a></p>
<p class="info" style="position:relative;top:0px;left:0px;color:black;font-size:30px:offset:0px">cite site:<a href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html">WebGLFundamentals</a></p>
<canvas id="glcanvas" style="position:relative;top:0px;left:0px;background-color:black;width:840px;height:480px;"></canvas>
<p id="PRINT_INFO" style="position:relative;top:0px;left:0px:offset:0px"></p>
<p id="PRINT_CAUTION" style="position:relative;top:0px;left:0px;color:red;offset:0px;"></p>
</div></body></html>
