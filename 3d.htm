<!DOCTYPE html><html lang="jp"><head><meta charset="utf-8"><title>WebGL Demo</title>
<link rel="sylesheet" href="">
<!--Fragment shader program-->
<script id="shader-fs" type="x-shader/x-fragment">
	varying lowp vec4 vColor;

	void main(void) {
		gl_FragColor = vColor;
	}
</script>
<!--Vertex shader program-->
<script id="shader-vs" type="x-shader/x-vertex">
	attribute vec3 aVertexPosition;
	attribute vec4 aVertexColor;

	uniform mat4 uModelViewMatrix;
	uniform mat4 uProjectionMatrix;

	uniform float uPointSizeFloat;

	varying lowp vec4 vColor;

	void main(void) {
		gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(aVertexPosition,1.0);
		vColor = aVertexColor;
		gl_PointSize = uPointSizeFloat;
	}
</script>

<script type='text/javascript'>

function start(){
	var canvas = document.createElement('canvas');
	var gl=canvas.getContext("webgl");
	if(!gl){
		alert('Unable to initialize WebGL.Your browser or machine may not support it.');
		return;
	}

	document.getElementsByTagName('body')[0].appendChild(canvas);
	canvas.id = "glcanvas";
	canvas.style.position='absolute';
	canvas.style.zIndex=100;
	canvas.style.left='0px';
	canvas.style.top='0px';
	canvas.width=640;
	canvas.height=480;


//	gl.clearColor(0.0, 0.0, 0.0, 0.5);	//Clear to black,fully opaque
//	gl.clearDepth(1.0);			//Clear everything
//	gl.enable(gl.DEPTH_TEST);		//Enable depth testing	    		// 深度テストを有効化
//	gl.depthFunc(gl.LEQUAL);		//Near things obscure far things	// 近くにある物体は、遠くにある物体を覆い隠す
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);


	var oShader = initShaders(gl);
	initBuffers(gl,oShader);


	var angle=0;
	function render(timeStamp){
		PRINT_INFO.innerHTML="";
		angle+=1.0;
		angle=Math.floor(angle*100)/100;
		if(angle>360)angle=0;
		PRINT_INFO.innerHTML+=angle.toString()+"<br>";
		drawScene(gl,oShader,angle);
		window.requestAnimationFrame(render);
	}
	window.requestAnimationFrame(render);
}

function initShaders(gl) {
	var fragmentShader = getShader(gl,"shader-fs");//プログラムをロードしてコンパイルして返す
	var vertexShader = getShader(gl,"shader-vs");//プログラムをロードしてコンパイルして返す

//onsole.log("fragmentShader=",fragmentShader);
//onsole.log("vertexShader=",vertexShader);



		//シェーダープログラムを作成
	var shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram,vertexShader);
	gl.attachShader(shaderProgram,fragmentShader);
	gl.linkProgram(shaderProgram);

	//シェーダープログラムを作成できない場合はアラートを表示
	if(!gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){
		alert("can't initialize the shader program");
		return null;
	}

	gl.useProgram(shaderProgram);//githubではdrawScene()内で実行

		//シェーダープログラムで使う配列変数を使用可能にする
	//プログラムのどこにあるのかを取得
	var positionLocation = gl.getAttribLocation(shaderProgram,"aVertexPosition");//""内は特殊言語の実装参照してる
	var colorLocation = gl.getAttribLocation(shaderProgram,"aVertexColor");

	//使ってもいいよリストに登録
	gl.enableVertexAttribArray(positionLocation);//githubではdrawScene()内で実行
	gl.enableVertexAttribArray(colorLocation);


	return {
		positionLoc:positionLocation,
		colorLoc:colorLocation,
		prog:shaderProgram
	}
}

function getShader(gl,id){
	var shaderScript,theSource,currentChild,shader;

	shaderScript = document.getElementById(id);

	if(!shaderScript) {
		return null;
	}

	theSource = "";
	currentChild = shaderScript.firstChild;

	while(currentChild) {
		if(currentChild.nodeType == currentChild.TEXT_NODE){
			theSource += currentChild.textContent;
		}

		currentChild = currentChild.nextSibling;
	}

	if (shaderScript.type == "x-shader/x-fragment"){
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	} else if (shaderScript.type == "x-shader/x-vertex"){
		shader = gl.createShader(gl.VERTEX_SHADER);
	} else {
		// 未知のシェーダータイプ
		return null;
	}

	gl.shaderSource(shader,theSource);

//onsole.log("before compile shader=",shader,gl);
	//シェーダープログラムをコンパイル
	gl.compileShader(shader);
//onsole.log("after compile shader=",shader,gl);

	//whether or not success to compileコンパイルが成功したかを確認
	if (!gl.getShaderParameter(shader,gl.COMPILE_STATUS)) {
		alert("シェーダーのコンパイルでエラーが発生しました: " + gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
}


function initBuffers(gl,oShader){

	//生成したバッファをWebGLBufferにバインドしたら、
	//あとはそれにvertexのattributionをbufferDataを使って
	//放り込んでゆくだけ

	var verticesBuffer = gl.createBuffer();//正方形のvertices
	gl.bindBuffer(gl.ARRAY_BUFFER,verticesBuffer);

	var positions = [
		1.0,1.0,-1.0,
		1.0,-1.0,-1.0,
		-1.0,-1.0,-1.0,
		-1.0,1.0,-1.0,
		0.0,0.0,-0.0,
		1.0,1.0,1.0,
		1.0,-1.0,1.0,
		-1.0,-1.0,1.0,
		-1.0,1.0,1.0

	];
	gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(positions),gl.STATIC_DRAW);

	var colors = [
		0.0, 1.0, 1.0, 1.0,
		1.0, 0.0, 0.0, 1.0,
		1.0, 1.0, 0.0, 1.0,
		1.0, 0.3, 1.0, 1.0,
		0.0, 0.0, 0.0, 1.0,
		0.0, 0.0, 1.0, 1.0,
		0.5, 1.0, 1.0, 1.0,
		0.6, 0.2, 0.4, 1.0,
		1.0, 0.9, 0.5, 1.0
	];
	gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(colors),gl.STATIC_DRAW);

		//バッファにある頂点情報をsend
		//send vertex information to WebGL script by using WebGLBuffer whitch has been stored vertex info by arrays
	{
	//var oShader.prop...specify the index of vertex attribute to be modifiedどのattributeを使うかを指定 
	var numComponents = 1;//githubでは2//A GLint specifying the number of components per vertex attribute.Must be 1,2,3,or 4.上で指定したattribute毎のコンポーネントの数
	var type = gl.FLOAT;//A GLenum specifying the data type of each component in the array.Possible values:
				//*gl.BYTE:signed 8-bit integer,with values in [-128,127]
				//*gl.SHORT:signed 16-bit integer,with values in [-32768,32767]
				//*gl.UNSIGNED_BYTE:
				//*gl.UNSIGNED_SHORT:
				//*gl.FLOAT:32-bit IEEE floating point number
				//When using a WebGL 2 context,the fllowing values are available additionally:
					//*gl.HALF_FLOAT:16-bit IEEE floating point nuber

	var normalize = false;
	var stride = 0;
	var offset = 0;


		//WebGLBufferにstoreしておいた、位置と色の情報を取り出す
		//WebGLBufferにjavascriptから配列で情報を渡し、WebGLBufferからWebGLスクリプトの変数に値を渡す
		//array --> buffer --> uniform
	numComponents = 3;//z座標を入れないでpositionsを作成した場合は2を指定してz座標には0が入るようにする
	gl.vertexAttribPointer(oShader.positionLoc,numComponents,type,normalize,stride,offset);//attribute vec4 aVertexLocation;
	numComponents = 4;//colorsは1つの頂点に4つのデータ(matrixの列数が4)だから。
	gl.vertexAttribPointer(oShader.colorLoc,numComponents,type,normalize,stride,offset);//attribute vec4 aVertexColor;

//○	gl.enableVertexAttribArray(vertexPositionAttribute);//initShader()内で実行済//githubではここで実行
//○	gl.useProgram(__shaderProgram__);//initShader()内で実行済//githubではここで実行
	}
}


function drawScene(gl,oShader,angle){

	// カラーバッファや深度バッファをクリアする
	//Clear the canvas before we start drawing on it

//	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	/*
		Create a perspective matrix, a special matrix that is
		used to simulate the distortion of perspective in a camera.
		Our field of view is 45 degrees, with a (width/height)
		ratio that matches the display size of the canvas
		and we only want ot see objects between 0.1 units
		and 100 units away from the camera.
	*/



		//perspective matrix
	{
	var fieldOfView = 10 * Math.PI / 180;	//in radian;
	var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
	var zNear = 0.01;
	var zFar = 100.0;
	makePMatrix(fieldOfView,aspect,zNear,zFar);//->_a (look like a face cf. b_a...フォントによるよね)
	var projectionMatrix=new Float32Array(16);intoArrayFromA(projectionMatrix);

	}

		//model view matrix
	{
	//単位行列
	makeTNorm();//->_t

	//移動
	_v11 = -0.0;
	_v21 =  0.0;
	_v31 = -20.0;
	translateTByV();//->_a

	//Tに入れなおし
	moveAtoT();//->_t

	//回転
	_v11 = -0.0;
	_v21 =  1.0;
	_v31 = -1.0;
	rotateTAroundV(angle*Math.PI/180);//->a

	var modelViewMatrix = new Float32Array(16);intoArrayFromA(modelViewMatrix);

	}

		//各行列をsend
		//Set the shader uniforms culclated above and something
	{
	//uniform mat4 uProjectionMatrixへ値を転送
	var pUniform = gl.getUniformLocation(oShader.prog,"uProjectionMatrix");//""内は特殊言語の実装参照してる
	gl.uniformMatrix4fv(pUniform,false,new Float32Array(projectionMatrix));

	//uniform mat4 uModelViewMatrixへ値を転送
	var mvUniform = gl.getUniformLocation(oShader.prog,"uModelViewMatrix");
	gl.uniformMatrix4fv(mvUniform,false,new Float32Array(modelViewMatrix));

	//uniform float uPointSizeFloatへ値を転送
	var psUniform = gl.getUniformLocation(oShader.prog,"uPointSizeFloat");
	gl.uniform1f(psUniform,10.0);
	}





	var offset = 0;
	var vertexCount = 9;

	gl.drawArrays(gl.TRIANGLE_STRIP,offset,vertexCount);
//	gl.drawArrays(gl.LINE_STRIP,offset,vertexCount);
//	PRINT_INFO.innerHTML+=gl.hasOwnProperty("PointSize").toString()+"<br>";
//	gl.drawArrays(gl.POINTS,offset,vertexCount);

}



</script>
<script id="matrix-library" type='text/javascript'>
var _t11,_t12,_t13,_t14,_t21,_t22,_t23,_t24,_t31,_t32,_t33,_t34,_t41,_t42,_t43,_t44;//target matrix
var _a11,_a12,_a13,_a14,_a21,_a22,_a23,_a24,_a31,_a32,_a33,_a34,_a41,_a42,_a43,_a44;//answer matrix
var _v11=void 0,_v21=void 0,_v31=void 0;//effect matrix
var _x11=void 0,_x21=void 0,_x31=void 0;//effect matrix


var intoArrayFromT = function MatrixTargetIsStoredIntoArray(arr){
	arr[0]=_t11;
	arr[1]=_t12;
	arr[2]=_t13;
	arr[3]=_t14;
	arr[4]=_t21;
	arr[5]=_t22;
	arr[6]=_t23;
	arr[7]=_t24;
	arr[8]=_t31;
	arr[9]=_t32;
	arr[10]=_t33;
	arr[11]=_t34;
	arr[12]=_t41;
	arr[13]=_t42;
	arr[14]=_t43;
	arr[15]=_t44;
}
var intoArrayFromA = function MatrixAnswerIsStoredIntoArray(arr){
	arr[0]=_a11;
	arr[1]=_a12;
	arr[2]=_a13;
	arr[3]=_a14;
	arr[4]=_a21;
	arr[5]=_a22;
	arr[6]=_a23;
	arr[7]=_a24;
	arr[8]=_a31;
	arr[9]=_a32;
	arr[10]=_a33;
	arr[11]=_a34;
	arr[12]=_a41;
	arr[13]=_a42;
	arr[14]=_a43;
	arr[15]=_a44;
}
var intoArrayFromV = function MatrixVIsStoredIntoArray(arr){
	arr[0]=_v11;
	arr[1]=_v21;
	arr[2]=_v31;
}
var makeTNorm = function MatrixTargetBecomeNormMatrix(){
	_t11=1;_t12=0;_t13=0;_t14=0;
	_t21=0;_t22=1;_t23=0;_t24=0;
	_t31=0;_t32=0;_t33=1;_t34=0;
	_t41=0;_t42=0;_t43=0;_t44=1;
}
var makeTAll1 = function MatrixTargetBecomesAll_1_Matrix(){
	_t11=1;_t12=1;_t13=1;_t14=1;
	_t21=1;_t22=1;_t23=1;_t24=1;
	_t31=1;_t32=1;_t33=1;_t34=1;
	_t41=1;_t42=1;_t43=1;_t44=1;
}
	


/**
 *Make perspective matrix
 *
 *@param {number} fov radian
 *@param {number} aspect width/height of screen
 *@param {number} near ?nearest distance to be able to take 
 *@param {number} far ?farthest distance to be able to take
*/
var makePMatrix = function makePerspectiveMatrixInMatrixAnswer(fov,aspect,near,far){
	if(near == far){
		PRINT_CAUTION.innerHTML += "far equals to near in makePMatrix().<br>";
		return null;
	}
	var s = 1.0 / Math.tan(fov / 2);
	var nf = 1 / (near - far);

	_a11 = s;		_a12 = 0;	_a13 = 0;			_a14 = 0;
	_a21 = 0;		_a22 = s;	_a23 = 0;			_a24 = 0;
	_a31 = 0;		_a32 = 0;	_a33 = far * nf;		_a34 = -1;
	_a41 = 0;		_a42 = 0;	_a43 = far*near * nf;		_a44 = 0;

//not important _a43,i think

//PRINT2.innerHTML = near.toString() + "&nbsp;&nbsp;&nbsp;" + far.toString() + "&nbsp&nbsp&nbsp" + (far*near*nf).toString();
//https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/building-basic-perspective-projection-matrix
}

/**
 *Translate 4x4matrix
 *
 *@param _t** {number} matrix to be translated
 *@param _v** {number} translate vector
 *@param _a** {number} matrix to be been translated
 *
*/
var translateTByV = function MatrixTargetIsTranslatedByMatrixV(){

	var x=_v11;
	var y=_v21;
	var z=_v31;

	_a11=_t11;					_a12=_t12;					_a13=_t13;					_a14=_t14;
	_a21=_t21;					_a22=_t22;					_a23=_t23;					_a24=_t24;
	_a31=_t31;					_a32=_t32;					_a33=_t33;					_a34=_t34;
	_a41=_t11*x + _t21*y + _t31*z + _t41;		_a42=_t12*x + _t22*y + _t32*z + _t42;		_a43=_t13*x + _t23*y + _t33*z + _t43;		_a44=_t14*x + _t24*y + _t34*z + _t44;
}

var rotateTAroundV = function MatrixTargetIsRotatedAroundV(rad){
	var len = Math.sqrt(_v11*_v11 + _v21*_v21 + _v31*_v31);
	if(len < 0.00001)return null;//????

	var x = _v11/len;
	var y = _v21/len;
	var z = _v31/len;

	var s = Math.sin(rad);
	var c = Math.cos(rad);
	var t = 1 - c;

	var r11 = x*x*t+c;	var r12 = y*x*t+z*s;	var r13 = z*x*t-y*s;
	var r21 = x*y*t-z*s;	var r22 = y*y*t+c;	var r23 = z*y*t+x*s;
	var r31 = x*z*t+y*s;	var r32 = y*z*t-x*s;	var r33 = z*z*t+c;

	_a11 = _t11 * r11 + _t21 * r12 + _t31 * r13;
	_a12 = _t12 * r11 + _t22 * r12 + _t32 * r13;
	_a13 = _t13 * r11 + _t23 * r12 + _t33 * r13;
	_a14 = _t14 * r11 + _t24 * r12 + _t34 * r13;

	_a21 = _t11 * r21 + _t21 * r22 + _t21 * r23;
	_a22 = _t12 * r21 + _t22 * r22 + _t22 * r23;
	_a23 = _t13 * r21 + _t23 * r22 + _t23 * r23;
	_a24 = _t14 * r21 + _t24 * r22 + _t24 * r23;

	_a31 = _t11 * r31 + _t11 * r32 + _t11 * r33;
	_a32 = _t12 * r31 + _t12 * r32 + _t12 * r33;
	_a33 = _t13 * r31 + _t13 * r32 + _t13 * r33;
	_a34 = _t14 * r31 + _t14 * r32 + _t14 * r33;
	
	_a41 = _t41;
	_a42 = _t42;
	_a43 = _t43;
	_a44 = _t44;
}


	


var moveAtoT = function MatrixAnswerMoveIntoMatrixTarget(){
	 _t11=_a11;
	 _t12=_a12;
	 _t13=_a13;
	 _t14=_a14;
	 _t21=_a21;
	 _t22=_a22;
	 _t23=_a23;
	 _t24=_a24;
	 _t31=_a31;
	 _t32=_a32;
	 _t33=_a33;
	 _t34=_a34;
	 _t41=_a41;
	 _t42=_a42;
	 _t43=_a43;
	 _t44=_a44;
};
</script>
</head><body onload="start();"><div>
<p id="PRINT_CAUTION" style="position:absolute;top:500px;left:0px;font-color:red;">こんにちわ</p>
<p id="PRINT_INFO" style="position:absolute;top:530px;left:0px">こんにちわ</p>
<p id="PRINT_LOG" style="position:absolute;top:560px;left:0px">こんにちわ</p>
<canvas></canvas></div></body></html>
