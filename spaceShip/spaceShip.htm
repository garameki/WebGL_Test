<!DOCTYPE html><html lang="jp"><head><meta charset="utf-8"><title>WebGL Demo</title>
<link rel="stylesheet"		type="text/css"		href="./styleSheet.css"></link>
<script id="library"		type="text/javascript"	src="./myLib.js"></script>
<script id="calculationXYZ"	type="text/javascript"	src="./accumeMotionsXYZ.js"></script>
<script id="matrix"		type="text/javascript"	src="./myMatrix.js"></script>
<script id="color"		type="text/javascript"	src="./myColor.js"></script>
<script id="class"		type="text/javascript"	src="./myClass.js"></script>
<script id="shape"		type="text/javascript"	src="./myGLShape.js"></script>
<script id="motions"		type="text/javascript"	src="./accumeMotions.js"></script>
<script id="textures"		type="text/javascript"	src="./myTextures.js"></script>






<!--******************************* SHADER PROGMRAMS *****************************************************-->
<!--Fragment shader-->
<script id="lightFragmentShader" type="x-shader/x-fragment">



//○	varying lowp vec4 vColor;	//as same as vertex shader
	varying highp vec4 vColor;//●	//as same as vertex shader
	varying highp vec2 vTextureCoord;//as same as vertex shader
	varying highp vec3 vNTimesEachRGB;//as same as vertex shader


	varying highp vec3 vXYZ;//test

	uniform mediump float uBrightness;
	uniform mediump float uAlpha;
	uniform mediump float uCassiniFactor;//if zero , not avairable,,if 1 , avairable

	uniform sampler2D uSampler;//common variable between shader and js

void hncodeFloat(float z){
	mediump vec4 bitShift = vec4(16777216.0,6400.0,256.0,1.0);
	mediump vec4 bitMask = vec4(0.0,1.0/256.0,1.0/256.0,1.0/256.0);

	mediump vec4 zzz = fract(vec4(z)*bitShift);
	zzz -=zzz.zxyz*bitMask;
	gl_FragColor = zzz;
}

	void main(void) {

		hncodeFloat(gl_FragCoord.z);

/*
vec4 encodeFloat (float depth) {
  vec4 bitShift = vec4(
256.0 * 256.0 * 256.0,
256.0 * 256.0,
256.0,
1.0
);
vec4 bitMask = vec4(
0.0,
1.0 / 256.0,
1.0 / 256.0,
1.0 / 256.0
);
vec4 comp = fract(depth * bitShift);
comp -= comp.xxyz * bitMask;
return comp;
}
*/
//x		gl_FragColor = texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t));
//		gl_FragColor = texture2D(uSampler,vTextureCoord);//mediump型
//		gl_FragColor = vColor;

		//uSamplerの数字とgl.TEXT0の数字は共通？

		mediump vec4 texelColor = texture2D(uSampler,vTextureCoord);//ja version

		mediump float gg = 1.0/pow(max(dot(texelColor,texelColor),1.0),3.0);

		mediump float shadowFlag =1.0;

		/* 0.99 < gl_FragCoord.z < 1.0 */
//		if(gl_FragCoord.z > 0.997){
//			shadowFlag = 1.0;
//		}else{
//			shadowFlag = 0.0;
//		};

		/* gl_Position.z is real z */
//		if(vXYZ.z < 10.0){
//			shadowFlag = 1.0;
//		}else{
//			shadowFlag = 1.0;
//		};

		/* gl_Position.z is real z */
		/* gl_FragDepth is not available ... */
//		if(gl_FragCoord.z == gl_FragDepthEXT/*gl_FragDepth*/){
//			shadowFlag = 1.0;
//		}else{
//			shadowFlag = 0.0;
//		};



		//http://www.chinedufn.com/webgl-shadow-mapping-tutorial/
//?		highp   vec4 texelColor = texture2D(uSampler,vTextureCoord);//en version
//		gl_FragColor = vec4(shadowFlag) * vec4(uBrightness)*vec4(texelColor.rgb * vNTimesEachRGB,(1.0-gg*uCassiniFactor)*uAlpha*texelColor.a);
//		gl_FragColor = encodeFloat(gl_FragCoord.z);

	}
</script>
<script id="lightVertexShader" type="x-shader/x-vertex">

	//'attribute' this type is used in vertex shader only.This type is assigned on buffers defined in js
	attribute vec3 aVertexNormal;//x y z
	attribute vec3 aVertexPosition;//x y z
	attribute vec4 aVertexColor;//R G B Alpha
	attribute vec2 aTextureCoord;//x y

	//The type of 'uniform' mainly matrices receipter from js
	uniform mat4 uModelViewMatrixInversedTransposed;
	uniform mat4 uModelViewMatrix;
	uniform mat4 uPerspectiveMatrix;
//●
	uniform mat4 uOrthographicMatrix;
	uniform mat4 uManipulatedRotationMatrix;
	uniform float uBaseLight;// 0.0-1.0 ?
	uniform float uPointSizeFloat;//a float value

//○	varying lowp vec4 vColor;
//○	varying lowp vec2 vTextureCoord;
	varying highp vec4 vColor;
	varying highp vec2 vTextureCoord;
	varying highp vec3 vNTimesEachRGB;

	varying highp vec3 vXYZ;//test


	void main(void) {



		gl_Position = uPerspectiveMatrix * uModelViewMatrix * vec4(aVertexPosition,1.0);
		gl_PointSize = uPointSizeFloat;
		vColor = aVertexColor;
		vTextureCoord = aTextureCoord;

		vXYZ = gl_Position.xyz;//test




		//compute a new position of a normal and slightly modify its direction which have been magnified to unequivalent directions.
		highp vec4 transformedNormal = uModelViewMatrixInversedTransposed * vec4(aVertexNormal,1.0);





		//compute a new position of the directional light
		highp vec3 directionalVector = normalize(vec3(0.85,0.8,0.75));//the direction of directional light at the first time
//あとで考慮	highp vec3 vec3(2.0) * directionalVectorNew = normalize(uManipulatedRotationMatrix * vec4(directionalVector,1.0)).xyz;//brightness*2//a new position of the light
		highp vec3 directionalVectorNew = normalize(uManipulatedRotationMatrix * vec4(directionalVector,1.0)).xyz;//brightness*2//a new position of the light


		//ここでdirectionalNewとorthographicMatrixを使って平行光源から見た物体のgl_Possitionを求め、そのgl_Colorを求め、shadowFactorをセットしたのち、perspectiveMatrixを使って新たにgl_Positionを設定しなおし、gl_Colorを設定する。
		//影は、色は黒、alphaは   変化なし  ですからね。


		vec3 centerVector = normalize(cross(directionalVectorNew,vec3(0.0,0.0,1.0)));//direct to observer's seen
		mediump float theta = acos(dot(directionalVectorNew,vec3(0.0,0.0,1.0)));
		//quaternion
//		mediump float ncos = cos(-theta*0.5);
//		mediump float nsin = sin(-theta*0.5);

		mediump float ncos = cos(-theta*0.5);
		mediump float nsin = sin(-theta*0.5);
		mediump float q0=ncos;
		mediump float q1=centerVector.x*nsin;
		mediump float q2=centerVector.y*nsin;
		mediump float q3=centerVector.z*nsin;


		mediump float qq0 = q0*q0;

		mediump float qq1 = q1*q1;
		mediump float qq2 = q2*q2;
		mediump float qq3 = q3*q3;

		mediump float qq12 = q1*q2*2.0;
		mediump float qq03 = q0*q3*2.0;
		mediump float qq13 = q1*q3*2.0;
		mediump float qq02 = q0*q2*2.0;
		mediump float qq23 = q2*q3*2.0;
		mediump float qq01 = q0*q1*2.0;

//		mediump mat2 test = transpose(mat2(1.0,1.0,1.0,1.0));
		mediump mat4 rotateLightDirection= mat4(qq0+qq1-qq2-qq3,qq12-qq03,qq13+qq02,0,qq12+qq03,qq0-qq1+qq2-qq3,qq23-qq01,0,qq13-qq02,qq23+qq01,qq0-qq1-qq2+qq3,0,0,0,0,1);

		//第一のpositionにはライトのベクトルの向きと反対方向にrotateするためのmatが必要
		gl_Position = uOrthographicMatrix * rotateLightDirection * uModelViewMatrix * vec4(aVertexPosition,1.0);
//		gl_Position = uPerspectiveMatrix * rotateLightDirection * vec4(aVertexPosition,1.0);











		//compute the brightness of the face using a new normal vector and using a new light direction
		highp float quantity = max(dot(transformedNormal.xyz,directionalVectorNew),uBaseLight);//scalar quantity as the light intensity
//		highp float quantity = max(dot(transformedNormal.xyz,directionalVectorNew),1.0);//scalar quantity as the light intensity

		highp vec3 directionalLightColor = vec3(1,1,1);//RGB intensity

		//ambient light
		highp vec3 ambientLight = vec3(0.1,0.1,0.1);//This is not the direction but the intensity of color.It does not have relationship with Normal Vector in vertex data.It relates with only 'gl_Color'.

		vNTimesEachRGB = ambientLight + (directionalLightColor * quantity);


		
	}

</script>
<script id="shader-fs" type="x-shader/x-fragment">



//○	varying lowp vec4 vColor;	//as same as vertex shader
	varying highp vec4 vColor;//●	//as same as vertex shader
	varying highp vec2 vTextureCoord;//as same as vertex shader
	varying highp vec3 vNTimesEachRGB;//as same as vertex shader


	varying highp vec3 vXYZ;//test

	uniform mediump float uBrightness;
	uniform mediump float uAlpha;
	uniform mediump float uCassiniFactor;//if zero , not avairable,,if 1 , avairable

	uniform sampler2D uSampler;//common variable between shader and js


	void main(void) {
//x		gl_FragColor = texture2D(uSampler,vec2(vTextureCoord.s,vTextureCoord.t));
//		gl_FragColor = texture2D(uSampler,vTextureCoord);//mediump型
//		gl_FragColor = vColor;

		//uSamplerの数字とgl.TEXT0の数字は共通？

		mediump vec4 texelColor = texture2D(uSampler,vTextureCoord);//ja version

		mediump float gg = 1.0/pow(max(dot(texelColor,texelColor),1.0),3.0);

		mediump float shadowFlag =1.0;


		//http://www.chinedufn.com/webgl-shadow-mapping-tutorial/
//?		highp   vec4 texelColor = texture2D(uSampler,vTextureCoord);//en version
		gl_FragColor = vec4(shadowFlag) * vec4(uBrightness)*vec4(texelColor.rgb * vNTimesEachRGB,(1.0-gg*uCassiniFactor)*uAlpha*texelColor.a);

	}
</script>





<!--Vertex shader-->
<script id="shader-vs" type="x-shader/x-vertex">

	//'attribute' this type is used in vertex shader only.This type is assigned on buffers defined in js
	attribute vec3 aVertexNormal;//x y z
	attribute vec3 aVertexPosition;//x y z
	attribute vec4 aVertexColor;//R G B Alpha
	attribute vec2 aTextureCoord;//x y

	//The type of 'uniform' mainly matrices receipter from js
	uniform mat4 uModelViewMatrixInversedTransposed;
	uniform mat4 uModelViewMatrix;
	uniform mat4 uPerspectiveMatrix;
//●
	uniform mat4 uManipulatedRotationMatrix;
	uniform float uBaseLight;// 0.0-1.0 ?
	uniform float uPointSizeFloat;//a float value

//○	varying lowp vec4 vColor;
//○	varying lowp vec2 vTextureCoord;
	varying highp vec4 vColor;
	varying highp vec2 vTextureCoord;
	varying highp vec3 vNTimesEachRGB;

	varying highp vec3 vXYZ;//test


	void main(void) {
		gl_Position = uPerspectiveMatrix * uModelViewMatrix * vec4(aVertexPosition,1.0);
		gl_PointSize = uPointSizeFloat;
		vColor = aVertexColor;
		vTextureCoord = aTextureCoord;

		vXYZ = gl_Position.xyz;//test




		//compute a new position of a normal and slightly modify its direction which have been magnified to unequivalent directions.
		highp vec4 transformedNormal = uModelViewMatrixInversedTransposed * vec4(aVertexNormal,1.0);





		//compute a new position of the directional light
		highp vec3 directionalVector = normalize(vec3(0.85,0.8,0.75));//the direction of directional light at the first time
		highp vec3 directionalVectorNew = vec3(2.0) * normalize(uManipulatedRotationMatrix * vec4(directionalVector,1.0)).xyz;//brightness*2//a new position of the light

		//compute the brightness of the face using a new normal vector and using a new light direction
		highp float quantity = max(dot(transformedNormal.xyz,directionalVectorNew),uBaseLight);//scalar quantity as the light intensity

		highp vec3 directionalLightColor = vec3(1,1,1);//RGB intensity

		//ambient light
		highp vec3 ambientLight = vec3(0.1,0.1,0.1);//This is not the direction but the intensity of color.It does not have relationship with Normal Vector in vertex data.It relates with only 'gl_Color'.

		vNTimesEachRGB = ambientLight + (directionalLightColor * quantity);
	}

</script>

<script type='text/javascript'>
/**
 * make shader
*/
(function(){
	myShaders = { };

	/** inner class **/
	var Shader = function(sNameShader,sIdVertex,sIdFragment,gl){
		this.gl = gl;
		this.programName = sNameShader;

		//read & compile
		var fragmentShader = getShader(gl,sIdFragment);
		var vertexShader = getShader(gl,sIdVertex);

		//make shader program
		var shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram,vertexShader);
		gl.attachShader(shaderProgram,fragmentShader);
		gl.linkProgram(shaderProgram);

		//alert in case of falure
		if(!gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){
			alert("can't initialize the shader program");
			this.program = null;
		}else{
			this.program = shaderProgram;
		}
	};
	Shader.prototype.activate = function(){
		if(this.program==null){
			alert("can't activate program");
		}else{
			this.gl.useProgram(this.program);
		}
	};

	/** inner function **/
	function getShader(gl,id){
		var shaderScript,theSource,currentChild,shader;

		shaderScript = document.getElementById(id);

		if(!shaderScript) {
			return null;
		}

		theSource = "";
		currentChild = shaderScript.firstChild;

		while(currentChild) {
			if(currentChild.nodeType == currentChild.TEXT_NODE){
				theSource += currentChild.textContent;
			}
			currentChild = currentChild.nextSibling;
		}

		if (shaderScript.type == "x-shader/x-fragment"){
			shader = gl.createShader(gl.FRAGMENT_SHADER);
		} else if (shaderScript.type == "x-shader/x-vertex"){
			shader = gl.createShader(gl.VERTEX_SHADER);
		} else {
			// unknown shader type
			PRINT_CAUTION.innerHTML+="Unknown shader type.The element type of shader program must be 'x-shader/x-vertex' or 'x-shader/x-fragment' now."+"<br>";
			return null;
		}

		gl.shaderSource(shader,theSource);

		gl.compileShader(shader);

		//recognize whether success to compile or not
		if (!gl.getShaderParameter(shader,gl.COMPILE_STATUS)) {
			alert("Shader compile error occured : " + id + " : " + gl.getShaderInfoLog(shader));
			return null;
		}
		return shader;
	};

	/** Property **/
	Object.defineProperty(myShaders,'create',{value:create,writable:false,enumerable:false,configurable:false});
	function create(sName,sIdVertex,sIdFragment,gl){
		Object.defineProperty(myShaders,sName,{value:new Shader(sName,sIdVertex,sIdFragment,gl),writable:false,enumerable:true,configrable:false});
	};
})();

function initShaders(gl) {
	var fragmentShader = getShader(gl,"shader-fs");//プログラムをロードしてコンパイルして返す
	var vertexShader = getShader(gl,"shader-vs");//プログラムをロードしてコンパイルして返す




		//シェーダープログラムを作成
	var shaderProgram = gl.createProgram();
	gl.attachShader(shaderProgram,vertexShader);
	gl.attachShader(shaderProgram,fragmentShader);
	gl.linkProgram(shaderProgram);

	//シェーダープログラムを作成できない場合はアラートを表示
	if(!gl.getProgramParameter(shaderProgram,gl.LINK_STATUS)){
		alert("can't initialize the shader program");
		return null;
	}

	gl.useProgram(shaderProgram);//githubではdrawScene()内で実行

	return shaderProgram;
};

function getShader(gl,id){
	var shaderScript,theSource,currentChild,shader;

	shaderScript = document.getElementById(id);

	if(!shaderScript) {
		return null;
	}

	theSource = "";
	currentChild = shaderScript.firstChild;

	while(currentChild) {
		if(currentChild.nodeType == currentChild.TEXT_NODE){
			theSource += currentChild.textContent;
		}

		currentChild = currentChild.nextSibling;
	}

	if (shaderScript.type == "x-shader/x-fragment"){
		shader = gl.createShader(gl.FRAGMENT_SHADER);
	} else if (shaderScript.type == "x-shader/x-vertex"){
		shader = gl.createShader(gl.VERTEX_SHADER);
	} else {
		// 未知のシェーダータイプ
		PRINT_CAUTION.innerHTML+="Unknown shader type.The element type of shader program must be 'x-shader/x-vertex' or 'x-shader/x-fragment' now."+"<br>";
		return null;
	}

	gl.shaderSource(shader,theSource);

	//シェーダープログラムをコンパイル
	gl.compileShader(shader);

	//whether or not success to compileコンパイルが成功したかを確認
	if (!gl.getShaderParameter(shader,gl.COMPILE_STATUS)) {
		alert("Shader compile error occured : " + id + " : " + gl.getShaderInfoLog(shader));
		return null;
	}

	return shader;
};


function getAttributeLocations(sName,gl,prog){
	//get shader variable pointer

	switch(sName){
		case "light":
			var locPosition = gl.getAttribLocation(prog,"aVertexPosition");gl.enableVertexAttribArray(locPosition);//githubではdrawScene()内で実行
			var locNormal = gl.getAttribLocation(prog,  "aVertexNormal");gl.enableVertexAttribArray(locNormal);
			var locColor = gl.getAttribLocation(prog,   "aVertexColor");gl.enableVertexAttribArray(locColor);
			var locTextcoord = gl.getAttribLocation(prog,"aTextureCoord");gl.enableVertexAttribArray(locTextcoord);

			return {
				position:locPosition,
				normal:locNormal,
				color:locColor,
				textcoord:locTextcoord
			}
		case "camera":
			var locPosition = gl.getAttribLocation(prog,"aVertexPosition");gl.enableVertexAttribArray(locPosition);//githubではdrawScene()内で実行
			var locNormal = gl.getAttribLocation(prog,  "aVertexNormal");gl.enableVertexAttribArray(locNormal);
			var locColor = gl.getAttribLocation(prog,   "aVertexColor");gl.enableVertexAttribArray(locColor);
			var locTextcoord = gl.getAttribLocation(prog,"aTextureCoord");gl.enableVertexAttribArray(locTextcoord);

			return {
				position:locPosition,
				normal:locNormal,
				color:locColor,
				textcoord:locTextcoord
			}
		default:
			PRINT_CAUTION.innerHTML+="'"+sName+"' haven't been defined yet.<br>"
	};

};

function getUniformLocations(sName,gl,prog){

	var vv;
	switch(sName){
		case "light":

			var locPerspective = gl.getUniformLocation(prog,"uPerspectiveMatrix");	if(!locPerspective){PRINT_CAUTION.innerHTML+="locPerspective is not used"+locPerspective+"<br>";}
			var locModelView = gl.getUniformLocation(prog, "uModelViewMatrix");	if(!locModelView){PRINT_CAUTION.innerHTML+="locModelView is not used"+locModelView+"<br>";}
			var locPointSize = gl.getUniformLocation(prog,  "uPointSizeFloat");	if(!locPointSize){PRINT_CAUTION.innerHTML+="locPointSize is not used"+locPointSize+"<br>";}
			var locSampler = gl.getUniformLocation(prog,    "uSampler");		if(!locSampler){PRINT_CAUTION.innerHTML+="locSampler is not used"+locSampler+"<br>";}
			var locModelViewMatrixInversedTansposed = gl.getUniformLocation(prog,"uModelViewMatrixInversedTransposed");	if(!locModelViewMatrixInversedTansposed){PRINT_CAUTION.innerHTML+="locModelViewMatrixInversedTansposed is notused"+locModelViewMatrixInversedTansposed+"<br>";}
			var locBaseLight = gl.getUniformLocation(prog,"uBaseLight");vv="locBaseLight";if(!eval(vv)){PRINT_CAUTION.innerHTML+=vv+" is not used"+eval(vv)+"<br>";}
			var locManipulatedRotationMatrix = gl.getUniformLocation(prog,"uManipulatedRotationMatrix");	if(!locManipulatedRotationMatrix){PRINT_CAUTION.innerHTML+="locManipulatedRotationMatrix is not used"+locManipulatedRotationMatrix+"<br>";}
			var locBrightness = gl.getUniformLocation(prog,"uBrightness");	if(!locBrightness){PRINT_CAUTION.innerHTML+="locBrightness is not used"+locBrightness+"<br>";}
			var locAlpha = gl.getUniformLocation(prog,"uAlpha");		if(!locAlpha){PRINT_CAUTION.innerHTML+="locAlpha is not used"+locAlpha+"<br>";}
			var locCassiniFactor = gl.getUniformLocation(prog,"uCassiniFactor");vv="locCassiniFactor";if(!eval(vv)){PRINT_CAUTION.innerHTML+=vv+" is not used"+eval(vv)+"<br>";}

			return {
				perspective:locPerspective,	
				modelView:locModelView,
				pointSize:locPointSize,
				sampler:locSampler,
				mvMIT:locModelViewMatrixInversedTansposed,
				baseLight:locBaseLight,
				manipulatedRM:locManipulatedRotationMatrix,
				brightness:locBrightness,
				alpha:locAlpha,
				cassiniFactor:locCassiniFactor,
			};
		case "camera":
			var locPerspective = gl.getUniformLocation(prog,"uPerspectiveMatrix");	if(!locPerspective){PRINT_CAUTION.innerHTML+="locPerspective is not used"+locPerspective+"<br>";}
			var locModelView = gl.getUniformLocation(prog, "uModelViewMatrix");	if(!locModelView){PRINT_CAUTION.innerHTML+="locModelView is not used"+locModelView+"<br>";}
			var locPointSize = gl.getUniformLocation(prog,  "uPointSizeFloat");	if(!locPointSize){PRINT_CAUTION.innerHTML+="locPointSize is not used"+locPointSize+"<br>";}
			var locSampler = gl.getUniformLocation(prog,    "uSampler");		if(!locSampler){PRINT_CAUTION.innerHTML+="locSampler is not used"+locSampler+"<br>";}
			var locModelViewMatrixInversedTansposed = gl.getUniformLocation(prog,"uModelViewMatrixInversedTransposed");	if(!locModelViewMatrixInversedTansposed){PRINT_CAUTION.innerHTML+="locModelViewMatrixInversedTansposed is notused"+locModelViewMatrixInversedTansposed+"<br>";}
			var locBaseLight = gl.getUniformLocation(prog,"uBaseLight");vv="locBaseLight";if(!eval(vv)){PRINT_CAUTION.innerHTML+=vv+" is not used"+eval(vv)+"<br>";}
			var locManipulatedRotationMatrix = gl.getUniformLocation(prog,"uManipulatedRotationMatrix");	if(!locManipulatedRotationMatrix){PRINT_CAUTION.innerHTML+="locManipulatedRotationMatrix is not used"+locManipulatedRotationMatrix+"<br>";}
			var locBrightness = gl.getUniformLocation(prog,"uBrightness");	if(!locBrightness){PRINT_CAUTION.innerHTML+="locBrightness is not used"+locBrightness+"<br>";}
			var locAlpha = gl.getUniformLocation(prog,"uAlpha");		if(!locAlpha){PRINT_CAUTION.innerHTML+="locAlpha is not used"+locAlpha+"<br>";}
			var locCassiniFactor = gl.getUniformLocation(prog,"uCassiniFactor");vv="locCassiniFactor";if(!eval(vv)){PRINT_CAUTION.innerHTML+=vv+" is not used"+eval(vv)+"<br>";}
	//●
			var locOrthography = gl.getUniformLocation(prog,"uOrthographicMatrix");vv="locOrthography";if(!eval(vv)){PRINT_CAUTION.innerHTML+=vv+" is not used"+eval(vv)+"<br>";}

			return {
				perspective:locPerspective,	
				modelView:locModelView,
				pointSize:locPointSize,
				sampler:locSampler,
				mvMIT:locModelViewMatrixInversedTansposed,
				baseLight:locBaseLight,
				manipulatedRM:locManipulatedRotationMatrix,
				brightness:locBrightness,
				alpha:locAlpha,
				cassiniFactor:locCassiniFactor,
//●
				orthography:locOrthography
			};
		default:
			PRINT_CAUTION.innerHTML+="'"+sName+"' haven't been defined yet.<br>"
	};
};









//******************************** BUFFERS *******************************




function assignBufferMapping(gl,oLocations,oBuffers){

	//usage of kinds of buffers when vertex shader reads them

	//** prepare common arguments **
	var type = gl.FLOAT;
	var normalize = false;
	var stride = 0;//shaderを呼び出すごとに進むバイト数//これは(buffer.slice((offset + i) * stride,size);)という意味
	var offset = 0;
	var numComponents;//number of column

	//positons
	gl.bindBuffer(gl.ARRAY_BUFFER,oBuffers.position);
	numComponents = 3;
	gl.vertexAttribPointer(oLocations.attribute.position,numComponents,type,normalize,stride,offset);

	//normal vector
	gl.bindBuffer(gl.ARRAY_BUFFER,oBuffers.normal);
	numComponents = 3;
	gl.vertexAttribPointer(oLocations.attribute.normal,numComponents,type,normalize,stride,offset);

	//color
	gl.bindBuffer(gl.ARRAY_BUFFER,oBuffers.color);
	numComponents = 4;
	gl.vertexAttribPointer(oLocations.attribute.color,numComponents,type,normalize,stride,offset);

	//texture
	gl.bindBuffer(gl.ARRAY_BUFFER,oBuffers.texture);
	numComponents = 2;
	gl.vertexAttribPointer(oLocations.attribute.textcoord,numComponents,type,normalize,stride,offset);

	//index
	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,oBuffers.index);//arrayのとおりにデータを使うのでPointerはいらない。

//kkk why it is not necessary for index to gl.vertexAttribPointer?
//Is the usage of array fixed?

//this part below is not necessary for the elements of indices (It's already defined as array data structure.)
//	numComponents = 3;//列の数
//	gl.vertexAttribPointer(oLocations.index,numComponents,type,normalize,stride,offset);

};

//********************************** VALUES FOR SHADER ****************************************

function sendOrthographicMatrix(gl,oLocations){

	/*
		https://www.scratchapixel.com/lessons/3d-basic-rendering/perspective-and-orthographic-projection-matrix/orthographic-projection-matrix		from cite site:
		orthographic matrix...myMat4 already has a property defined
	*/
	var right = 1000.0;
	var left = -1000.0;
	var top = 1000.0;
	var bottom = -1000.0;
	var far = 1000.0;
	var near = -1000.0;
	var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;

	myMat4.loadOrthography(left,right,top,bottom,near,far,aspect);

	//uniform mat4 uOrthographicMatrixへ値を転送
	gl.uniformMatrix4fv(oLocations.uniform.orthography,false,new Float32Array(myMat4.arr));

};



function sendPerspectiveMatrix(gl,oLocations){

	/*
		from cite site:
		Create a perspective matrix, a special matrix that is
		used to simulate the distortion of perspective in a camera.
		Our field of view is 45 degrees, with a (width/height)
		ratio that matches the display size of the canvas
		and we only want ot see objects between 0.1 units
		and 100 units away from the camera.
	*/
		//perspective matrix...myMat4 already has a property defined about this
//	var fieldOfView = 70 * Math.PI / 180;	//in radian;
	var fieldOfView = 70 * Math.PI / 180;	//in radian;
	var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
	var zNear = 0.1;
	var zFar = 10000000.0;

	//create a projectionMatrix array as the perspective matrix
	var projectionMatrix=new Array(16);
	myMat4.loadPerspective(fieldOfView,aspect,zNear,zFar);
	projectionMatrix = myMat4.arr;

	//uniform mat4 uPerspectiveMatrixへ値を転送
	gl.uniformMatrix4fv(oLocations.uniform.perspective,false,new Float32Array(projectionMatrix));

	return projectionMatrix;
};


function sendModelViewMatrix(gl,oLocations,arrAccumelationToMyMat4,angle){
	//@param {Array} aMVMatrices model view matrix in Array
		//Set the shader uniforms culclated above and something

	myMat4.loadIdentity();//initialize accumelator of matrix to compute

	for(var ii=0,len=arrAccumelationToMyMat4.length;ii<len;ii++){
		arrAccumelationToMyMat4[ii](angle);
	}
	var mvMat = myMat4.arr;

	//uniform mat4 uModelViewMatrixへ値を転送
	gl.uniformMatrix4fv(oLocations.uniform.modelView,false,new Float32Array(mvMat));

	return mvMat;//for inversing and transposing in another 'send' function
};

/**
 *各面の法線ベクトルの向きを更新＆拡大縮小にともなうずれを修正してくれる便利なベクトルをシェーダーに送る。
 *send a matrix which rotates and translate normal vector and which makes the direction of normal vectors correct,especially when magnifiring was done to its body
*/
function sendModelViewMatrixInversedTransposed(gl,oLocations,mvMatrix){

	//compute matrix
	myMat4.load(mvMatrix);
	myMat4.inverse();
	myMat4.transpose();
			//https://msdn.microsoft.com/ja-jp/library/ms810476.aspx
			//	says the reason 'inverse & transpose' above

	//uniform highp mat4 umvMatrixITに値を転送
	gl.uniformMatrix4fv(oLocations.uniform.mvMIT,false,new Float32Array(myMat4.arr));
};
//●-
function sendBaseLight(gl,oLocations,fNumber){//移動修正したあとのnormalに影響を与えるためのマトリックスをsendする send a matrix to affect each normals after having been multiplied by inversingTransposing matrix
	gl.uniform1f(oLocations.uniform.baseLight,fNumber);
};
//-●
function sendSampler(gl,oLocations,number){
	//uniform float uPointSizeFloatへ値を転送
	gl.uniform1i(oLocations.uniform.sampler,number);
};
function sendPointSize(gl,oLocations,nSize){
	//uniform float uPointSizeFloatへ値を転送
	gl.uniform1f(oLocations.uniform.pointSize,nSize);
};

function sendManipulatedRotationOnly(gl,oLocations,arrAccumelationToMyMat4,angle){//ライトの位置を視点の回転と共に移動させる

	myMat4.loadIdentity();
	for(var ii=0,len=arrAccumelationToMyMat4.length;ii<len;ii++){
		arrAccumelationToMyMat4[ii](angle);
	}
	gl.uniformMatrix4fv(oLocations.uniform.manipulatedRM,false,new Float32Array(myMat4.arr));
};

function sendBrightness(gl,oLocations,nValue){
	//uniform float uPointSizeFloatへ値を転送
	gl.uniform1f(oLocations.uniform.brightness,nValue);
};
function sendAlpha(gl,oLocations,nValue){
	//uniform float uPointSizeFloatへ値を転送
	gl.uniform1f(oLocations.uniform.alpha,nValue);
};
function sendCassiniFactor(gl,oLocations,fValue){
	gl.uniform1f(oLocations.uniform.cassiniFactor,fValue);
};


//************************************** DRAW SCENE *************************************************


function drawScene(gl,oShader,angle){

	// カラーバッファや深度バッファをクリアする
	//Clear the canvas before we start drawing on it

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	var vertexOffset = 0;//このoffsetは頂点のx,y,zごとに進むので、データ的にはoffset*3(4?)ごとに進む
	var nPointSize = 3.0;

	var member,mvmat,pmat;
	for(var ii=0;ii<UnitsToDraw.length;ii++){
		member = UnitsToDraw.getMemberByIndex(ii);
		assignBufferMapping(gl,oShader.camera.locations,member.buffers);//attribute variables are allocated before,change the buffers
		pmat = sendPerspectiveMatrix(gl,oShader.camera.locations);
		mvmat = sendModelViewMatrix(gl,oShader.camera.locations,member.aAccumeUnits,angle);
//●
		sendOrthographicMatrix(gl,oShader.camera.locations);
		sendModelViewMatrixInversedTransposed(gl,oShader.camera.locations,mvmat);
		sendBaseLight(gl,oShader.camera.locations,member.baseLight);
		sendPointSize(gl,oShader.camera.locations,nPointSize);
		sendSampler(gl,oShader.camera.locations,0);//kkk Is last argument unit number?
		sendManipulatedRotationOnly(gl,oShader.camera.locations,member.aAccumeUnitsLight,angle);
		sendBrightness(gl,oShader.camera.locations,member.brightness);
		sendAlpha(gl,oShader.camera.locations,member.alpha);
		sendCassiniFactor(gl,oShader.camera.locations,member.cassiniFactor);
		myTextures.member[member.nameTexture].activate();
		member.draw();//in which texture activated is for use
		member.labels.repos(gl,pmat,mvmat);
	}
};


//*************************************** START ****************************************************************	
//start
function start(){

	//** prepare gl canvas **//
	var canvas = document.getElementById('glcanvas');
	canvas.width=canvas.clientWidth;//necessary
	canvas.height=canvas.clientHeight;//necessary
	var gl=canvas.getContext("webgl2");
	if(!gl){
		alert('Unable to initialize WebGL.Your browser or machine may not support it.');
		return;
	}
	gl.viewport(0,0,gl.canvas.width,gl.canvas.height);//(kkk bad)クリップ空間の-1～1の値をcanvasの大きさに変換する
	gl.clearColor(0.0, 0.0, 0.0, 1.0);	//Clear to black,fully opaque
	gl.clearDepth(1.0);			//Clear everything
	gl.enable(gl.DEPTH_TEST);		//Enable depth testing	    		// 深度テストを有効化
	gl.depthFunc(gl.LEQUAL);		//Near things obscure far things	// 近くにある物体は、遠くにある物体を覆い隠す
{
	//https://stackoverflow.com/questions/47216022/webgl-gl-fragcolor-alpha-behave-differently-in-chrome-with-firefox
	//i've been thanking David Guan
	gl.enable(gl.BLEND);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
};
{
//	//not available
//	//https://stackoverflow.com/questions/24499321/using-gl-fragdepth-in-webgl
//	//https://www.khronos.org/registry/webgl/sdk/tests/conformance/extensions/ext-frag-depth.html
//	gl.getExtension("EXT_frag_depth");
//	if(gl.getSupportedExtensions().indexOf("EXT_frag_depth") >= 0){
//		PRINT_CAUTION.innerHTML+="you CAN use extention gl_FragDepth in frag-shader<br>";
//	}else{
//		PRINT_CAUTION.innerHTML+="you CAN'T use extention gl_FragDepth in frag-shader<br>";
//	}
};

	//** rectangle test **
	//{
	//	gl.viewport(0,0,gl.drawingBufferWidth,gl.drawingBufferHeight);
	//    gl.enable(gl.SCISSOR_TEST);
	//   gl.scissor(30, 10, 60, 60);//60x60の正方形
	//    gl.clearColor(1.0, 1.0, 0.0, 1.0);
	//    gl.clear(gl.COLOR_BUFFER_BIT);
	//};


	//** prepare shaders **/
	myShaders.create("camera","shader-vs","shader-fs",gl);
	myShaders.create("light","lightVertexShader","lightFragmentShader",gl);
	myShaders.camera.activate();
//kkk


	var oAttributeLocations	= {
			light:getAttributeLocations("light",gl,myShaders.light.program),
			camera:getAttributeLocations("camera",gl,myShaders.camera.program)
	};
	var oUniformLocations	= {
		light :getUniformLocations("light",gl,myShaders.light.program),
		camera:getUniformLocations("camera",gl,myShaders.camera.program)
	};		
	var oShader = {
		light:{
			program	: myShaders.light.program,
			locations:{
				attribute : oAttributeLocations.light,
				uniform	: oUniformLocations.light
			}
		},
		camera:{
			program	: myShaders.camera.program,
			locations:{
				attribute : oAttributeLocations.camera,
				uniform	: oUniformLocations.camera
			}
		}
	};


//test
	//myFRBuffers.create("shadow",gl,1024,1024);
	//myFRBuffers.shadow.activate();
	//myFRBuffers.shadow.inactivate();







	//** prepare textures **
	var nameTextureSun = "sun";
	myTextures.join(gl,nameTextureSun);
	var nameTextureBase = "earth";
	myTextures.join(gl,nameTextureBase);
	var nameTextureMoon = "moon";
	myTextures.join(gl,nameTextureMoon);
	var nameTextureJupiter = "jupiter";
	myTextures.join(gl,nameTextureJupiter);
	var nameTextureUranus = "uranus";
	myTextures.join(gl,nameTextureUranus);
	var nameTextureVenus = "venus";
	myTextures.join(gl,nameTextureVenus);
	var nameTextureMars = "mars";
	myTextures.join(gl,nameTextureMars);
	var nameTextureNeptune = "neptune";
	myTextures.join(gl,nameTextureNeptune);
	var nameTextureMercury = "mercury";
	myTextures.join(gl,nameTextureMercury);
	var nameTextureRing = "ring";
	myTextures.join(gl,nameTextureRing);
	var nameTextureSaturn = "saturn";
	myTextures.join(gl,nameTextureSaturn);





	var nameTextureAtomosphere = "white";
//issue	myTextures.create(gl,nameTextureAtomosphere,myColorName.white(0.5));//preserve alpha here
	myTextures.join(gl,nameTextureAtomosphere);







	var _front_=true;
	var _frontLength_ = 60;




	/* class & instances */
	(function(){
		var mag = 0.001;
		Ball = function(radius){
			this.radiusSurface = radius;
		};
		Object.defineProperty(Ball.prototype,'radius',{get:function(){return mag*this.radiusSurface;},enumerable:true,configurable:false});
	})();
	var sun		= new Ball(695508);
	var jupiter	= new Ball(71492);
	var saturn	= new Ball(60268);
	var uranus	= new Ball(25559);
	var neptune	= new Ball(24764);
	var earth	= new Ball(6378);
	var venus	= new Ball(6051);
	var mars	= new Ball(3396);
	var mercury	= new Ball(2439);
	var moon	= new Ball(1738);
	var pluto	= new Ball(1195);




	/** common **/
	var brightnessCommon = 1.0;
	var brightnessAtomosphere = 1.0;
	var brightnessSun = 1.1;
	var alphaCommon = 1.0;
	var alphaAtomosphere = 0.3;
	var alphaRing = 0.6;

	var cassiniFactorCommon = 0.0;
	var cassiniFactorRing = 1.0;

	var baseLight = 0.0;
	var baseLightSun = 1.0;

	var colorNameText = myColorName.blue(0.5);

		//plane
	var xyzCenter = myXYZManipulation.createMember();
	var aAccumeUnits = [];
	if(_front_){
		aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));
		var labels = new myClass.Labels();
		labels.addText(0,-1,0,"ship",colorNameText);
	} else {
		aAccumeUnits.push(AccumeMotions.translate(0,0,10));
		var labels = new myClass.Labels();
		labels.addText(0,-5,0,"",colorNameText);
	};
	var shape = myGLShape.hexa(gl);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureBase,[],brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);




	/** for Sun **/
	var aAccumeLightingSun = [];
	aAccumeLightingSun.push(AccumeMotions.gotoOrigin());


		//Sun
	var r = sun.radius;
	var xyzSun = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));
////●	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));

	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyzSun));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));

	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));
						//	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,    1,-1,0));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));//center : sun
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,-5,0,"Sun",colorNameText);
//	var shape = myGLShape.hexa(gl);
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureSun,aAccumeLightingSun,brightnessSun,alphaCommon,baseLightSun,cassiniFactorCommon);


	/** common **/
	var aAccumeLighting = [];
	aAccumeLighting.push(AccumeMotionsXYZ.replaceViewNotTrans(xyzCenter));


		//Earth
	var r = earth.radius;
	var xyzEarth = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));

//	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyzEarth));//revolution公転
//	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));

	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));
						//	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,    1,-1,0));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));//center : sun
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,-5,0,"Earth",colorNameText);
//	var shape = myGLShape.hexa(gl);
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureBase,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);




	/** Atomosphere of Earth **/
	//not texture but color
	var r = earth.radius*1.05;
	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));
//	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyzEarth));//revolution公転
//	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));
						//	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,    1,-1,0));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));//center : sun
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,-5,0,"",colorNameText);
//	var shape = myGLShape.hexa(gl);
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureAtomosphere,aAccumeLighting,brightnessAtomosphere,alphaAtomosphere);





	/** Jupiter **/
	var r = jupiter.radius;
	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));//rotation自転
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyz));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,"Jupitor",colorNameText);//kkk
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureJupiter,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);



	/** Moon **/
	var r = moon.radius;
	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));//rotation自転
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyz));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,nameTextureMoon,colorNameText);//kkk
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureMoon,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);


	/** Uranus **/
	var r = uranus.radius;
	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));//rotation自転
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyz));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,nameTextureUranus,colorNameText);//kkk
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureUranus,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);


	/** Venus **/
	var r = venus.radius;
	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));//rotation自転
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyz));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,nameTextureVenus,colorNameText);//kkk
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureVenus,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);


	/** Mars **/
	var r = mars.radius;
	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));//rotation自転
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyz));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,nameTextureMars,colorNameText);//kkk
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureMars,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);


	/** Neptune **/
	var r = neptune.radius;
	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));//rotation自転
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyz));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,nameTextureNeptune,colorNameText);//kkk
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureNeptune,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);


	/** Mercury **/
	var r = mercury.radius;
	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));//rotation自転
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyz));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,nameTextureMercury,colorNameText);//kkk
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureMercury,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);


	/** Saturn **/
	var r = saturn.radius;
	var xyzSaturn = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));//rotation自転
	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyzSaturn));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,nameTextureSaturn,colorNameText);//kkk
	var shape = myGLShape.sphere(gl,r);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureSaturn,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);



	/** Ring **/
	var rOut = saturn.radius*2.327;
	var rIn = saturn.radius*1.116086;
//	var xyz = myXYZTrigonometry.createMember();
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotions.rotate(1,0,0,0,90));
//	aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
	aAccumeUnits.push(AccumeMotionsXYZ.trans(xyzSaturn));//revolution公転
	aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
	if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
						//	aAccumeUnits.push(AccumeMotions.axisY(1));
						//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
						//	aAccumeUnits.push(AccumeMotions.none());
	var labels = new myClass.Labels();
	labels.addText(0,0,0,"",colorNameText);//kkk
	var shape = myGLShape.ring(gl,rIn,rOut);
	UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureRing,aAccumeLighting,brightnessCommon,alphaRing,baseLightSun,cassiniFactorRing);



	/** satellite thrown in various random directions **/
/*
	for(var hh=0;hh<10;hh++){
		var r = moon.radius;
		var xyz = myXYZTrigonometry.createMember();
		var aAccumeUnits = [];
		aAccumeUnits.push(AccumeMotions.rotate(0,1,0,1,0));//rotation自転
			aAccumeUnits.push(AccumeMotionsXYZ.trans(xyz));//revolution公転
			aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
			if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));//seen from the distance
							//	aAccumeUnits.push(AccumeMotions.axisY(1));
							//	aAccumeUnits.push(AccumeMotions.translate(0,0,-50));
							//	aAccumeUnits.push(AccumeMotions.none());
		var labels = new myClass.Labels();
		labels.addText(0,0,0,hh.toString(),colorNameText);//kkk
		var shape = myGLShape.sphere(gl,r);
		UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureAsteroid,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);
	};

*/


	/* These two kinds of objects below must always be lighten from right angle ,so that they are lighten most brightly*/

	/** common variables**/
	var aAccumeLighting = [];
	aAccumeLighting.push(AccumeMotions.translate(1.0,1.0,1.0));//Light is put at (1 1 1)
	aAccumeLighting.push(AccumeMotionsXYZ.replaceViewNotTrans(xyzCenter));//always (1 1 1) as same relationship of positionning


	//stars far from planet
	var spread=100;
	var p1,r1,t1;
	for(var hh=0;hh<100;hh++){
		var aAccumeUnits=[];
		aAccumeUnits.push(AccumeMotionsXYZ.replaceView(xyzCenter));
		if(_front_)aAccumeUnits.push(AccumeMotions.translate(0,0,-_frontLength_));
		var labels = new myClass.Labels();
		//labels.addText(0,0,-10,"hexa",colorNameText);
		r1 = 1000*Math.random()+1000;
		t1 = 3.141592653*2*Math.random();
		t2 = 3.141592653*Math.random()-1.5707963265;
		r2 = r1*Math.cos(t2);
		p1 = new myClass.Point(r2*Math.cos(t1),r2*Math.sin(t1),r1*Math.sin(t2));
		var shape = myGLShape.point(gl,p1,myColorName.purple(1));
		UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureBase,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);
	}


	/** x,y,z axes **/
	var aAccumeUnits = [];
	aAccumeUnits.push(AccumeMotionsXYZ.replaceViewNotTrans(xyzCenter));
	aAccumeUnits.push(AccumeMotions.translate(-30,-15,-30));
	var labels = new myClass.Labels();
	labels.addText(0,0,5,"back",colorNameText);
	var shape = myGLShape.line(gl,new myClass.Point(0,0,0),new myClass.Point(0,0,5),myColorName.magenta(1));
		UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureBase,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);
	var labels = new myClass.Labels();
	labels.addText(0,5,0,"up",colorNameText);
	var shape = myGLShape.line(gl,new myClass.Point(0,0,0),new myClass.Point(0,5,0),myColorName.magenta(1));
		UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureBase,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);
	var labels = new myClass.Labels();
	labels.addText(5,0,0,"right",colorNameText);
	var shape = myGLShape.line(gl,new myClass.Point(0,0,0),new myClass.Point(5,0,0),myColorName.magenta(1));
		UnitsToDraw.join(gl,shape,aAccumeUnits,labels,nameTextureBase,aAccumeLighting,brightnessCommon,alphaCommon,baseLight,cassiniFactorCommon);



//********************************************** animation ****************************************************	
	var timeBefore=0;
	var angle=0;
	var dt;
	function render(timeStamp){
		dt = timeStamp - timeBefore;
		if(dt>10){
			angle+=dt/16;
			//if(angle>360)angle=0;
			PRINT_INFO.innerText=angle.toString();
			myXYZTrigonometry.reposAll(dt);
			myXYZManipulation.move(dt);
//			drawScene(gl,oShader.camera,angle);
			drawScene(gl,oShader,angle);
			timeBefore = timeStamp;
		}
		window.requestAnimationFrame(render);
	}
	window.requestAnimationFrame(render);
};//start


//**************************** 3D DRAW with MOVING, LIGHTING, TEXTURING, COLORING and so on *************************************************


/* all the things to be wanted to draw must be thrown into 'oModel',e.g. shape or text with its position x,y,z*/
(function(){


	//
	//@param {myGLShape.obj} shape in which there are points,color,normal vector,indeces and so on
	//
	var ToolBox = function(gl,shape,aMotions,aLabels,sNameTexture,aLights,brightness,alpha,fBaseLight,fCassiniFactor){//f means float
		this.draw = shape.draw;
		this.buffers = createBuffers(gl,shape);
		this.aAccumeUnits = aMotions;
		this.labels = aLabels;
		this.nameTexture = sNameTexture;

		this.aAccumeUnitsLight = aLights;
		this.brightness = brightness;
		this.alpha = alpha;
		this.baseLight = fBaseLight;

		this.cassiniFactor = fCassiniFactor;
	};

	/** inner function**/
	function createBuffers(gl,shape){
		//生成したバッファをWebGLBufferにバインドしたら、
		//あとはそれにvertexのattributionをbufferDataを使って
		//頂点の座標、頂点の色、テキストデータなどをバッファに放り込むだけ

		//position to buffer
		var bufPositions = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER,bufPositions);
		gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(shape.pos),gl.STATIC_DRAW);

		//normal vectors to buffer//●
		var buffNormal = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER,buffNormal);
		gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(shape.nor),gl.STATIC_DRAW);

		//color to buffer
		var buffColors = gl.createBuffer();//正方形のvertices
		gl.bindBuffer(gl.ARRAY_BUFFER,buffColors);
		gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(shape.col),gl.STATIC_DRAW);

		//texture position to buffer
		var buffTextureCoordinate = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER,buffTextureCoordinate);
		gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(shape.tex),gl.STATIC_DRAW);

		//indices to ELEMENT buffer
		var buffIndex = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,buffIndex);
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array(shape.ind),gl.STATIC_DRAW);

		return {
			position : bufPositions,
			texture : buffTextureCoordinate,
			normal : buffNormal,
			color : buffColors,
			index : buffIndex
		};
	};



	var aModels = [];

	UnitsToDraw = { };
	Object.defineProperty(UnitsToDraw,'join',{value:create,writable:false,enumerable:true,configurable:false});	
	function create(gl,shape,aMotions,aLabels,sNameTexture,aLightMotions,brightness,alpha,fBaseLight,fCassiniFactor){
		aModels.push(new ToolBox(gl,shape,aMotions,aLabels,sNameTexture,aLightMotions,brightness,alpha,fBaseLight,fCassiniFactor));
	}
	Object.defineProperty(UnitsToDraw,'getMemberByIndex',{value:function(num){return aModels[num];},writable:false,enumerable:true,configurable:false});
	Object.defineProperty(UnitsToDraw,'length',{get:function(){return aModels.length;},enumerable:true,configurable:false});
})();//UnitsToDraw

//******************************************** framebuffer & renderBuffer **************************************************
/**
 *make render buffer with frame buffer and texture of void
*/
(function(){
	//myFRBuffers object
	myFRBuffers = { };

	/** inner class **/
	  //Texture, Framebuffer and Renderbuffer are necessary at once.
	  //http://www.chinedufn.com/webgl-shadow-mapping-tutorial/
	var FRBuffer = function(gl,width,height){
		this.gl = gl;
		this.width = width;
		this.height = height;

		this.texture = gl.createTexture();//into which frame buffer store
		gl.bindTexture(gl.TEXTURE_2D,this.texture);
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.NEAREST);
		gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,width,height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);

		this.renderbuffer = gl.createRenderbuffer();
		gl.bindRenderbuffer(gl.RENDERBUFFER,this.renderbuffer);
		gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_COMPONENT16,width,height);

		this.framebuffer = gl.createFramebuffer();
		gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,this.texture,0);
		gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,this.renderbuffer);
	};
	FRBuffer.prototype.activate = function(){
		this.gl.viewport(0,0,this.width,this.height);
		this.gl.bindTexture(this.gl.TEXTURE_2D,null);
		this.gl.bindRenderbuffer(this.gl.RENDERBUFFER,null);
	};
	FRBuffer.prototype.inactivate = function(){
		this.gl.viewport(0,0,this.gl.canvas.width,this.gl.canvas.height);
		this.gl.bindFramebuffer(this.gl.FRAMEBUFFER,null);
	};


	Object.defineProperty(myFRBuffers,'create',{value:create,writable:false,enumerable:true,configurable:false});
	function create(sName,gl,width,height){
		Object.defineProperty(myFRBuffers,sName,{value:new FRBuffer(gl,width,height),writable:false,enumerable:true,configurable:true});
	};
})();

</script>

</head><body style="overflow:hidden;" onload="start();"><div>
<h3 style="offset:0px;">Animating objects with WebGL</h3>
<h5 style="offset:0px;">using gl.TRIANGLES mode to draw and not using gl.ELEMENT_ARRAY_BUFFER mode to buffer</h5>
<p class="info" style="position:relative;top:0px;left:0px;color:black;font-size:30px:offset:0px">cite site:<a href="https://developer.mozilla.org/ja/docs/Web/API/WebGL_API/Tutorial/Lighting_in_WebGL">MDN web docs moz://a(click next page)</a></p>
<p class="info" style="position:relative;top:0px;left:0px;color:black;font-size:30px:offset:0px">cite site:<a href="https://webglfundamentals.org/webgl/lessons/webgl-drawing-multiple-things.html">WebGLFundamentals</a></p>
<div id="canvasContainer">
<canvas id="glcanvas" style="position:relative;top:0px;left:0px;background-color:black;width:840px;height:480px;"></canvas>
</div>
<p id="PRINT_INFO" style="position:relative;top:0px;left:0px:offset:0px"></p>
<p id="PRINT_CAUTION" style="position:absolute;top:0px;left:0px;color:red;font-size:8px;line-height:8px;offset:0px;background-color:transparent;"></p>
</div></body></html>

